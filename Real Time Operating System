A general definition of embedded systems is: embedded systems are computing systems with tightly coupled
hardware and software integration, that are designed to perform a dedicated function.The word embedded reflects
the fact that these systems are usually an integral part of a larger system, known as the embedding system. Multiple
embedded systems can coexist in an embedding system.they are systems within systems.They either cannot or do not function on their own.

In some cases, embedded systems can function as standalone systems. The network router.

The processors found in common personal computers (PC) are general-purpose or universal processors.
They are designed to be suitable for a variety of applications.But
embedded processors are special-purpose processors designed for a specific class of applications.

The key is
application awareness, i.e., knowing the nature of the applications and meeting the requirement for those applications
that it is designed to run.

some embedded
processors are limited in functionality, i.e., a processor is good enough for the class of applications for which it was
designed but is likely inadequate for other classes of applications. This is one reason why many embedded
processors do not have fast CPU speeds. For example, the processor chosen for a personal digital assistant (PDA)
device does not have a floating-point co-processor because floating-point operations are either not needed or
software emulation is sufficient.

Commonly both the hardware and the software for an embedded system are developed in parallel. Constant design
feedback between the two design teams should occur in this development model.



Random Access Memory (RAM)
Also called Read/Write Memory, requires external power to maintain memory content. The term random access
refers to the ability to access any memory cell directly. RAM is much faster than ROM. Two types of RAM that are
of interest:
•Dynamic RAM (DRAM) DRAM is a RAM device that requires periodic refreshing to retain its content.
•Static RAM (SRAM) SRAM is a RAM device that retains its content as long as power is supplied by an
external power source. SRAM does not require periodic refreshing and it is faster than DRAM.
•Non-Volatile RAM (NVRAM) NVRAM is a special type of SRAM that has backup battery power so it
can retain its content after the main system power is shut off. Another variation of NVARM combines
SRAM and EEPROM so that its content is written into the EEPROM when power is shut off and is read
back from the EEPROM when power is restored.


What is RealTimeEmbedded System?
-->In the simplest form, real-time systems can be defined as those systems that respond to external events in a timely
fashion,The response is guarrated.

External events can have synchronous or asynchronous characteristics. Responding to external events includes
recognizing when an event occurs, performing the required processing as a result of the event, and outputting the
necessary results within a given time constraint. Timing constraints include finish time, or both start time and finish time.

It can be seen that not all embedded systems exhibit real-time behaviors
nor are all real-time systems embedded. However, the two systems are not mutually exclusive, and the area in which
they overlap creates the combination of systems known as real-time embedded systems.

Figure 1.7: Structure of real-time systems.
The structure of a real-time system, as shown in Figure 1.7, is a controlling system and at least one controlled system.
The controlling system interacts with the controlled system in various ways. First, the interaction can be periodic, in
which communication is initiated from the controlling system to the controlled system. In this case, the communication
is predictable and occurs at predefined intervals. Second, the interaction can be aperiodic, in which communication
is initiated from the controlled system to the controlling system. In this case, the communication is unpredictable and is
determined by the random occurrences of external events in the environment of the controlled system. Finally, the
communication can be a combination of both types. The controlling system must process and respond to the events
and information generated by the controlled system in a guaranteed time frame.

Example 1:
Imagine a real-time weapons defense system whose role is to protect a naval destroyer by shooting down incoming
missiles. The idea is to shred an incoming missile into pieces with bullets before it reaches the ship. The weapons
system is comprised of a radar system, a command-and-decision (C&D) system, and weapons firing control system.
The controlling system is the C&D system, whereas the controlled systems are the radar system and the weapons
firing control system.
•
•
•
The radar system scans and searches for potential targets. Coordinates of a potential target are sent to the
C&D system periodically with high frequency after the target is acquired.
The C&D system must first determine the threat level by threat classification and evaluation, based on the
target information provided by the radar system. If a threat is imminent, the C&D system must, at a minimum,
calculate the speed and flight path or trajectory, as well as estimate the impact location. Because a missile
tends to drift off its flight path with the degree of drift dependent on the precision of its guidance system, the
C&D system calculates an area (a box) around the flight path.
The C&D system then activates the weapons firing control system closest to the anticipated impact location
and guides the weapons system to fire continuously within the moving area or box until the target is
destroyed. The weapons firing control system is comprised of large-caliber, multi-barrel, high-muzzle
velocity, high-power machine guns.


In this weapons defense system example, the communication between the radar system and the C&D system is
aperiodic, because the occurrence of a potential target is unpredictable and the potential target can appear at any
time. The communication between the C&D system and the weapons firing control system is, however, periodic
because the C&D system feeds the firing coordinates into the weapons control system periodically (with an extremely
high frequency). Initial firing coordinates are based on a pre-computed flight path but are updated in real-time
according to the actual location of the incoming missile.


Most RTOS kernels contain the following components:
Scheduler-is contained within each kernel and follows a set of algorithms that determines which task
executes when. Some common examples of scheduling algorithms include round-robin and preemptive
scheduling.

Objects-are special kernel constructs that help developers create applications for real-time embedded
systems. Common kernel objects include tasks, semaphores, and message queues.


Services-are operations that the kernel performs on an object or, generally operations such as timing,
interrupt handling, and resource management.


1)Scheduler
-->The scheduler is at the heart of every kernel. A scheduler provides the algorithms needed to determine which task
executes when. To understand how scheduling works, this section describes the following topics:
--Schedulable entities 
--multitasking
--context switching
--dispacther
--scheduling algorithm

#Schedulable entities:
Tasks and processes are all examples of schedulable entities found in most kernels.



why we need conventional, as well as unconventional RTOS platforms?
   -->conventional embedded sw development are 
      more closer to bare-metal embedded 
      sw platforms
         -->a bare-metal embedded sw platform will be 
            OS-unaware 
         -->these stacks will be light-weight and very 
            thin 
         -->application/jobs will be closely coupled, 
            with the embedded hw platform and its 
            features
         -->in bare-metal platforms, overheads due to 
            resource management and 
            run-time management will be 
            very less      
->typically, such a bare-metal stack will 
       not support multi-tasking and OS related
       features, but just chip drivers and support
       for a "super-loop based application" - "a simple 
       while loop, that keeps processing one or more
       jobs - there is no multitasking of jobs"   
     ->typically for an embedded application, the 
       stack will be a thin layer/component/module
       on top which the application/jobs are built
     ->which means, the application is very tightly 
       coupled, with the underlying hw platform/
       architecture/peripherals
     ->in "this context of super-loop model/design", 
       timing/real-time issues can be a problem, due to 
       latencies/jitters and accumulated latencies/
       jitters - if one 
       of the job's is facing timing problems/latencies/
       jitters, 
       this will propagate to other jobs of the 
       super-loops and 
       affect the timing performance of the 
       other jobs 
     
-->in the bare-metal case, the design 
           is similar to a single threaded application
           --->there is just a single main, 
               which is the only thread of 
               execution, in the system  
        
-->timing/real-time issues of jobs cannot be 
           satisfied - due to lack of multi-tasking/
           scheduling/prioritization 
           
           -->multi-tasking and scheduling of jobs 
           cannot be satisfied 
        -->prioritization of jobs/tasks cannot be 
           done 
        -->related issues, like blocking and wake-up 
           of separate jobs is not possible
           --->we may implement certain interrupt 
               based techniques, but not as good
               as OS blocking mechanisms
               
-->the system programs the systick to generate 
            periodic interrupts, for processing 
            a cyclic scheduler 
        -->whenever there is a periodic systick 
           event,  cyclic scheduler is invoked/
           triggered /processed 
        -->there is a well defined tasks' list 
           , with appropriate parameters 
           -->there will be a TCB/task control 
              block/a system object to manage a
              task/thread - in this context, 
              tasks are unconventional threads   
            -->TCB will contain period of a task/
               task method 
            -->TCB will contain task method's address
            -->each task method is assigned 
               an embedded job 
            -->TCB will contain a time-offset, for 
               the first scheduling/processing of the 
               task/method 
               
    -->there is no time-slice 
             -->task methods are processed - there 
                is no blocking support, for tasks -
                the cyclic scheduler will scan the 
                list of TCBs, in the list and process
                their methods, as per the parameters, 
                in the TCBs, based on offset/period  
             -->the cyclic scheduler is a co-operative 
                scheduler
             -->job of a task will have WCET/worst case
                execution time(real-time parameter/ 
                               performance)
--->WCET is a real-time performance parameter, 
    for real-time sensitive applications/jobs
    
           -->if WCETs are unacceptable, other
              tasks' methods will be affected - 
              their scheduling/release times 
              are affected
      -->many of the above details are part of task 
         modelling/designing - designing tasks, for 
         jobs of an application, based on the 
         application's requirements, including 
         periodic tasks, period of tasks, offsets of 
         tasks, tick period, ordering of tasks, and 
         many more               
               
--->in these simpler embedded sw platforms, 
       simple multitasking is provided :
       --->no blocking 
       --->no preemption(special cases may exist)
       --->only ready and running states, for 
           tasks 
       --->only one form of scheduling policy 
 
 
the platform will be supported, 
       by a "single address-space", "without protection, 
       in a conventional RTOS system
       
       
-->what is the meaning of single address-space and
           without memory protection ???
            -->in these contexts, let us assume, that 
               a single physical address-space is used
         --->still, there will segments/regions
             and their characteristics
--->many of these hw features are based on the 
    hw platforms 
            -->code/data of application/tasks, as well
               as code/data of RTOS will be resident, in 
               a single address-space - in fact, code/data of 
               application/tasks and code/data of RTOS 
               are linked and grouped together - 
               this is very similar to bare-metal embedded
               platforms
 
        --->a single embedded sw image is generated, 
                   containing RTOS code/data and application/
                   tasks code and data 
        
        
      -->what is the meaning of no memory protection ??
               -->data of application and RTOS are unprotected
               -->for instance, if a task illegally 
                  attempts to modify a system object, 
                  it will be allowed to do so - system 
                  data is unprotected
               -->if there is a stack overflow, in a task's
                  stack region, it can affect another task's
                  data or system data - this is also an 
                  unprotected memory management   
--->all these are due to a single address-space 
    set-up
  
  
       ->for instance, in the context a conventional 
           RTOS, it may not be using MPU services or 
           may be using MPU services - most likely, 
           may not use MPU services, for regular 
           applications - "non-MPU model is the more 
           likely design"
            -->in the case of conventional RTOS, 
               the port may be a "non-MPU port" - 
               meaning, MPU is disabled and no form 
               of memory protection is supported, for 
               application/jobs/tasks and RTOS code/data 
            -->initially, let us assume, that we will 
               be working, with non-MPU ports 
 
 ---->however, working, with MPU port RTOS is more 
     challenging, practically
     
     
     ->will support well defined "sw timer management 
       and related frame-works" - these "sw timers are
       built on top of hw timers and RTOS frame-works" 
       to support tasks/jobs 
        --->based on the requirements, we can 
            have reasonable number of sw timers
            --->since hw timers are limited, 
                sw timers can be easily/reasonably 
                provided to applications
           --->continue reading, for more 
               practical discussions on sw timers 
--->some of the following points are embedded related 
     ->will support a well defined RTOS-aware HAL, 
       for interacting with processor architecture
       and chip/board features
        -->RTOS-aware processor HAL(abstraction)
           -->this HAL layer is fine tuned, for 
              RTOS requirements 
           -->services provided by this HAL will be 
              used , by RTOS core components  
        -->RTOS-aware chip/board bsp/drivers(chip/board)
        
############Task Management

-->   -->tasks are managed, using TCBs - in addition, as 
      per the current state of tasks/TCBs, they are 
      managed, in different system lists:

let us understand
     the design and details of a typical,conventional 
     RTOS platforms, from "embedded perspective" :

->single address-space design
        ->the processor/controller may have MPU 
          , but disabled 
        ->since the MPU is disabled, a there is 
          a default physical memory map of the processor/
          controller that is effective 
           -->some region/segment, for all code
           -->some region/segment, for all data/stack/heap
                 --->rtos needs to manage more 
                     stack segments 
           -->there will one or more memory-mapped 
              IO segments/regions
           -->there may be other segments/regions, 
              for other embedded requirements  
        ->in this default set-up, "single memory-map/
          address-space", code of application and 
          code of RTOS components are linked and 
          resident, in a single memory region/
          segment 
        ->in this default set-up, single memory-map/
          address-space, "data of application and 
          data of RTOS components are linked and 
          resident", in a single memory region/
          segment 
        ->for conventional/simple RTOS designs/models, 
          we do not have logical addresses/virtual 
          addresses - later, we will see different 
          RTOS designs/models, with logical address-spaces
          and virtual address-spaces  
        ->this set-up is due to hw memory-map 
          and used, as single address-space by 
          RTOS and application - there are no 
          restrictions/protections, for application code to 
          access RTOS code or RTOS data - this can 
          be vulnerable/unreliable, for certain 
          critical applications/systems



---->in a typical bare-metal embedded application, 
     we may just use a single stack or two stacks, 
     not more  
          ->these task stack memory regions are associated
            with PSP of the processor - meaning, they 
            will be used/effective, in the context 
            of execution of a specific task/job, 
            in thread mode of the processor - for 
            each task, there is a separate thread mode
            stack - as per the specific task/task method, 
            PSP is switched to appropriate thread mode stack
             -->no. of thread mode stacks will be same
                as that of no. of tasks/jobs 
             -->no. of main stacks ?? only one  
             -->these are true, for a specific design   
          ->in this set-up, we need to configure/
            re-configure physical address-space /
            segments, as per application requirements, 
            but subject to the rules of RTOS
          ->we will be using certain embedded techniques, 
            for changing the memory-map /layout, along 
            with RTOS configuration /initialization 
            techniques/more skills 
             -->explore linker scripts and their 
                scripting techniques - refer to 
                good embedded sw references 
             -->we will see certain scenarios, in 
                the context of RTOS, with MPU model 
                --->some of the techniques/skills
                    are required, in this MPU model 
---->non-MPU model is relatively simpler      
         --> BSP is low-level sw 
             supporting chip features and board
             features, including chip initialization, 
             chip specific device-drivers, and board
             specific device drivers.
             
->so, in our context, HAL means low-level 
             sw that deals, with stack management, 
             privilege managment, interrupt management 
             , exception managment,processor's 
             hw timer  management, MPU management 
             and others, if any
             --->it is a core component of 
                 a RTOS/EOS platform 
           ->there are bare-metal HALs and BSPs, 
             as well as EOS/RTOS-aware HALs and 
             BSPs             
             
->it is very common to find Vendors 
             providing bare-metal HALs and BSPs, 
             that can be modified and used by 
             embedded developers
    ->it is very uncommon to find vendors
             providing EOS/RTOS-aware HALs and 
             BSPs -even if provided, will be 
             incomplete and need changes and 
             thorough testing - most of these 
             points apply to RTOS , as well as 
             Embedded Linux systems
      
->for a given hw platform, with "a cpui, 
               chipj and boardj combination", there will be an 
               HALi and BSPj 
          ->for another given hardware platform, with 
               "a cpui, chipj+1 and boardj+1", there will 
               be an HALi and BSPj+1
             ->in the above cases, EOS core/RTOS core 
               mostly remains the same and it is 
               portable,using different HAL/BSP modules, 
               as per requirements 
               -->a good set of scenarios, for 
                  modularity       
     in this conventional 
            RTOS set-up, there are no system call
            APIs/system calls
            
             --->what happens, if a system APIi of 
          RTOS core is invoked, by the current 
          task/currently scheduled task/task method  ??
          -->in this model, there is a single 
             address-space and task/method execute
           , with privilege level 
          -->so, there is no need, for mode switch/
             privilege-level switch
          -->so, this RTOS system just exports/provides 
             system APIs, not system call APIs 
          -->when a system API is invoked, there 
             is "no mode-switch/privilege level 
             switch/no stack switch"
          --->our embedded application is typically 
             linked to RTOS library/code/data, 
             statically - no separate RTOS image/
             system space  
          -->system API is still processed, in the 
             same task context - all the rules 
             of a typical task context apply
         --->since it is a task context, cpu mode
             is thread mode 
          -->the stack used is thread mode stack of 
             the thread  
          -->this execution is, as good as 
             a typical task method's execution 
          -->however, if the system API is a blocking 
             system API, it may block the current 
             task /TCB and invoke the RTOS 
             cpu scheduler           
          -->execution of system APIs is also known 
             as kernel execution paths of RTOS core
           - in addition, as per the design, in 
             any of the kernel execution paths, 
             processor will be, in privileged 
             level
           - as per the design, tasks/task methods
             will be executed, in thread mode of 
             the processor
           - most kernel paths of execution are 
             executed, in thread mode of the processor
             
if a task is executing 
             and a hw interrupt event is generated, 
             there will be a special jump and 
             corresponding RTOS-aware-ISR will 
             be invoked  
             --->context of execution will be 
                 interrupt context + there will 
                 a stack switch to MSP stack +
                 mode switch to handler mode +
                 continues, in privileged level  
-->task periods and offsets are 
           typically provided to 
           control the periodic executions of 
           tasks - it may also be used to 
           control the order of execution of tasks 
          , as per task modelling/design patterns               


